
Time efficient for this algorithm is O(E+V)

ShortestPathBFS(Graph G, Vertex source, Vertex destination):
    // Initialize
    for each vertex v in G:
        v.color = WHITE
        v.d = ∞
        v.π = NIL
    source.color = GRAY
    source.d = 0
    source.π = NIL
    
    // Initialize Queue
    Q = Queue()
    Q.enqueue(source)
    
    // BFS
    while Q is not empty:
        u = Q.dequeue()
        if u == destination:
            return ReconstructPath(source, destination)
        for each vertex v in G.adj[u]:
            if v.color == WHITE:
                v.color = GRAY
                v.d = u.d + 1
                v.π = u
                Q.enqueue(v)
        u.color = BLACK
    return "No path exists"

ReconstructPath(Vertex source, Vertex destination):
    path = []
    current = destination
    while current != source:
        path.prepend(current)
        current = current.π
    path.prepend(source)
    return path
